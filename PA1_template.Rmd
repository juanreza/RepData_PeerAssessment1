# Patterns of Steps:  Reproducible Research Assignment 1
<!-- "Назначение 1: узоры в шагов: повторяемым научные исследования" -->
<!-- title: "Patterns of Steps:  Reproducible Research Assignment 1" -->
<!--
setwd("c:/edu/_DataScienceJohnsHopkins/_ReproducibleResearch/_ASGN1")
source("PA1_template.Rmd")
-->
<!-- # узоры в пешеходных шагов.-->

Juan Reza
6/11/2015

`r Sys.setlocale("LC_ALL", "C")`

This document is for [Assignment 1](https://class.coursera.org/repdata-015/human_grading/view/courses/973516/assessments/3/submissions).

# Abstract

We want to discover the differences in activity patterns between weekdays and weekends.
We also want to find the time of day when the most steps occur.
 To operationalize this approach we take 5-minute intervals across all days in a sample, and compute the average number of steps at each time of day. The interval with the greatest number of steps (on average) reveals the pattern of interest.

# Introduction

This is an assignment that models a study of the number of foot steps throughout the day over several days. 

## Exploratory analysis

A preliminary exploration of the dataset revealed that the data arrives sorted by date and interval, see [sort-check procedure](#checksorted).

An informal count of missing data points showed that only about	1.3%	percent of data that is missing measurements, thus suggesting that bias would be negligible. However, the calculations would be error-prone if ommissions are allowed. 

# Analysis of Data 

## Data Cleaning
The presence of missing-data placeholders, **NA**, could bias the analysis. Another researcher ([Peng](https://class.coursera.org/repdata-015/lecture/59)) suggested that missing data could be filled in by taking an average of steps at the corresponding interval across all days sampled. However, that model could introduce a bias to the comparison of weekdays versus weekends. For example, averaging in weekday steps during lunch would add unjustified steps to a corresponding  interval with a missing measureent on the weenend. Other less-scheduled times of walking could also introduce unjustified measurement estimates.

**Interpolation Model**: This study assumes that walking/running patterns are similar among <b>adjacent</b> 5-minute intervals. As such, this study supplies an estimate of steps at missing points by interpolating a value from the previous and subsequent non-NA intervals on the same day. 

For example, if you take 50 steps in interval i, and you take 40 steps in interval i+2 (on the same day), we assume that you did not come to a stop or suddenly sprint solely in interval i+1. We impute 45 steps in interval i+1 by interpolation of the nearest non-missing points. Similarly, if you took no steps surrounding an interval with missing data, we assume you also took no steps then.

<!-- main data-cleaning function: interpolate values to replace NA steps -->
```
opts_chunk$set( echo=FALSE)
{r setoptions, echo=FALSE}
```


Treat 3 consecutive intervals with an NA as single 15 minute interval
`r MINOR_GAP  <-  function() { 3 }`


`r cleanData  <-  function(t) {
  previousValue <- 0L
  nextValue <- t[[2,1]]
  nextValue <- if ( is.na(nextValue)) 0L
  n <- nrow(t)
  
# traverse table and fix all NA step values by interpolation to adjacent values 
  previousValue <- 0L

  for ( i in 1L:(n-1)) {
    if ( is.na( t[[i,1]] )) { #1
      t[[i,1]] <-  as.integer( mean( c(previousValue, nextValue)))
      if ( is.na( t[[i,1]])) {
         t[[i,1]] <- 0L
      }
      
# setup next nextValue
      if ( ! is.na(t[[ i+1, 1]]))   {
        nextValue <- t[[ i+1, 1]] # the easy case.
                     
      } else { # infer next step (after present visited ith and next is NA
       
        if ( previousValue==0 ) { # no activity across adjacent intervals
          nextValue <- 0L
          
        } else { # find next near non-NA step value and use that
          nextValue <- 0L
        
          # get next non-NA value. assume continued activity thru gap
          for (j in (i+ MINOR_GAP()):(i+1)) {
            if ( ! is.na( t[[ j,1]] )) {
              nextValue <- as.integer( t[[ j,1]] )
              
            } else {
              nextValue <- as.integer( 
                  nextValue * ( MINOR_GAP() / (MINOR_GAP() +1)) )
            }
          }
        }
      }

# interpolate present step 
#  from known previous and inferred next non-NA step value
      t[[i,1]] <-as.integer( mean(c(previousValue, nextValue)) )
      
    } else { 
      # no processing  of this cell needed: i-th is not NA
    }
     
    # setup new previousValue for the next iteration
    previousValue <- as.integer( t[[i,1]])
  }
  t # return clean data.frame
}
`

The details are provided in the [Supplementary: interpolation of missing data](#interpolate) section.

<!-- analytic functions declarations -->
`r initActivityData <- function() {
  t <-  read.table( "activity.csv",  header=TRUE, sep=",",  comment.char = "#",  quote = "\"", stringsAsFactors=FALSE)
t
}

t <- initActivityData ()`


`r totalStepsEachDayFunction <- function(t) {
  daysRows <- t[,"date"]
  days <- daysRows[!duplicated(daysRows) ]

  stepInDays <- integer()
  for (day in days) {
    stepInDays[day] <- sum( t[  t$date==day, ][, "steps"] , na.rm=TRUE)
  }
stepInDays 
}`

`r meanStepsEachDayFunction <- function(t) {
  daysRows <- t[,"date"]
  days <- daysRows[!duplicated(daysRows) ]
  meanStepsEachDay <- sum( t$steps, na.rm=TRUE) / length(days)
  meanStepsEachDay
}`


`r totalStepsEachDayHistogram <- function( totalStepsEachDay) { 

  daysRows <- t[,"date"]
  days <- daysRows[!duplicated(daysRows) ]

  dayNumber <-  1:length( days)
#TODO: x is dayNumber

  hist( totalStepsEachDay, col="yellow", oma="2", 
  xlab="Total Steps By Day" , main="Total Steps By Day" )
 abline( v=12, lwd=2)
 axis(side=1, at=seq(0,100, 10), labels=seq(0,1000,100))
 invisible()
}`



`r meanOfTotalStepsPerDayfunction <- function( totalStepsEachDay ) {
  meanMaxSteps <- mean( totalStepsEachDay , na.rm=TRUE)
meanMaxSteps 
}`

`r medianOfTotalStepsPerDayfunction <- function( totalStepsEachDay ) {
  medianMaxSteps <- median( totalStepsEachDay , na.rm=TRUE)
medianMaxSteps 
}`



`r histClean <- function( tClean ) { # plot
  totalStepsEachDay <- totalStepsEachDayFunction(tClean )
  totalStepsEachDayHistogram( totalStepsEachDay  )
 #  invisible()
}`



`r plotMeanStepsByInterval <- function( t) {
  
  meanOfTotalStepsAllIntervals1 <- numeric( 24*12 ) # 24 hours times 12 five-minute intervals per hour
  
  for (i in 1: length(meanOfTotalStepsAllIntervals1)) {
    intervalbaseMinute <-  (i-1)*5
    meanOfTotalStepsAllIntervals1[i] <- mean( t[ t$interval==intervalbaseMinute ,]$steps , na.rm = TRUE)
    if ( is.nan(meanOfTotalStepsAllIntervals1[i])) { meanOfTotalStepsAllIntervals1[i] <- 0}
  }
  par( mfrow=c(2,1) )
  par( cex=0.6)
  par(mar=c(3,3,0,0))
  plot( c(1:( 24*12)) , meanOfTotalStepsAllIntervals1, type="l" , main="Raw mean steps per interval across all days", col="red")
  invisible()
}`


`r intervalWithMaxMeanStepsByInterval <- function( t) {
  
  meanOfTotalStepsAllIntervals1 <- numeric( 24*12 ) # 24 hours times 12 five-minute intervals per hour
  intervalWithMax <- 0L
  
  for (i in 1: length(meanOfTotalStepsAllIntervals1)) {
    intervalbaseMinute <-  (i-1)*5
    m <- mean( t[ t$interval==intervalbaseMinute ,]$steps , na.rm = TRUE)
    if ( is.nan(m)) { m <- 0L}
    intervalWithMax <- if( m > intervalWithMax) meanOfTotalStepsAllIntervals1[i]
  }
  intervalWithMax
}`

`r intervalWithMaxMeanStepsByIntervalBYMAXOFARRAY <- function( t) {
  
  meanOfTotalStepsAllIntervals1 <- numeric( 24*12 ) # 24 hours times 12 five-minute intervals per hour
  intervalWithMax <- 0L
  
  for (i in 1: length(meanOfTotalStepsAllIntervals1)) {
    intervalbaseMinute <-  (i-1)*5
    meanOfTotalStepsAllIntervals1[i] <- max( t[ t$interval==intervalbaseMinute ,]$steps , na.rm = TRUE)
    if ( is.nan(meanOfTotalStepsAllIntervals1[i])) { meanOfTotalStepsAllIntervals1[i] <- 0L}
  }
  intervalWithMax <- max(meanOfTotalStepsAllIntervals1)
  intervalWithMax
}`


`r maxMeanStepsByInterval <- function( t) {
  
  meanOfTotalStepsAllIntervals1 <- numeric( 24*12 ) # 24 hours times 12 five-minute intervals per hour
  
  for (i in 1: length(meanOfTotalStepsAllIntervals1)) {
    intervalbaseMinute <-  (i-1)*5
    meanOfTotalStepsAllIntervals1[i] <- mean( t[ t$interval==intervalbaseMinute ,]$steps , na.rm = TRUE)
    if ( is.nan(meanOfTotalStepsAllIntervals1[i])) { meanOfTotalStepsAllIntervals1[i] <- 0}
  }
  max <- max( meanOfTotalStepsAllIntervals1)
  max
}`


`r  totalMissingValues <- function(t) {
  missingCount <- length( t$steps[ is.na(t$steps)])
  missingCount
}`


`r tClean <- cleanData(t)
weekdayWeekendFactor <-  factor( c(1,2), levels=c("Weekdays","Weekends"))`

# for each interval number, get mean of steps in that interval across each day
`r plotWeekdayVsWeekendPanelFunction <- function( tClean) {
  tClean$wkt <-  ifelse( strftime( tClean$date, format="%u") %in% c("6","7"), 2, 1)
  
  weekdayWeekendFactor <- factor(tClean$wkt, c(1,2), labels=c("WeekDay","WeekEnd"))
  tCleanWeekday <-  tClean[ tClean$wkt == 1, ]
  tCleanWeekend <-  tClean[ tClean$wkt == 2, ]
  tClean$wkt <- weekdayWeekendFactor
    
  meanOfTotalStepsAllIntervals1 <- numeric( 24*12 ) # 24 hours times 12 five-minute intervals per hour
  meanOfTotalStepsAllIntervals2 <- numeric( 24*12 )
                                            
  for (i in 1: length(meanOfTotalStepsAllIntervals1)) {
    intervalbaseMinute <-  (i-1)*5
    meanOfTotalStepsAllIntervals1[i] <- mean( tCleanWeekday[ tCleanWeekday$interval==intervalbaseMinute ,]$steps )
     if ( is.nan(meanOfTotalStepsAllIntervals1[i])) { meanOfTotalStepsAllIntervals1[i] <- 0}
    meanOfTotalStepsAllIntervals2[i] <- mean( tCleanWeekend[ tCleanWeekend$interval==intervalbaseMinute ,]$steps )
     if ( is.nan(meanOfTotalStepsAllIntervals2[i])) { meanOfTotalStepsAllIntervals2[i] <-0}
  }
  
  par( mfrow=c(2,1) )
  par( cex=0.6)
  par(mar=c(3,3,0,0))
  plot( c(1:( 24*12)) , meanOfTotalStepsAllIntervals1, type="l" , main="Weekdays", col="blue") # xLim=c(100:288))
  plot( c(1:( 24*12)) , meanOfTotalStepsAllIntervals2, type="l" , main="Weekends", col="purple") # xLim=c(100:288))
  invisible()
}
`
<!-- ------------------------------------------------
1. Load the data  
2. Process/transform the data  -->
## Procedure

To run this script, set working directory to the location of your local copy of activity.csv . Obtain a copy of [activity.csv](#activity.csv) from the assignment repository.

<!-- Loading and preprocessing the data -->
The method of loading and processing data are shown in the  [Data Cleaning section](#supp).
<!-- 1. Load the data -->
`r t <- initActivityData()`


<!-- What is mean total number of steps taken per day? -->
### Mean total number of steps taken per day

<!-- For this part of the assignment, you can ignore the missing values in the dataset 
-->
This section explores the raw data. The raw data includes missing points where data was scheduled to be measured and failed to be captured.

The method of loading and processing data are shown in the  [Data Cleaning section](#supp).

<!--  1. Calculate the total number of steps taken per day-->

The total number of steps observed per day is  `r  totalStepsEachDay<-totalStepsEachDayFunction(t)
totalStepsEachDay`.
  
<!-- 2. If you do not understand the difference between a histogram and a barplot, research the difference between them. Make a histogram of the total number of steps taken each day -->
Following is an exploratory histogram of the total number of steps observed by day.

totalStepsEachDayHistogram( totalStepsEachDay)

<!--3. Calculate and report the mean and median of the total number of steps taken per day -->
The  mean total number of steps observed per day is r meanOfTotalStepsPerDayfunction (  totalStepsEachDay ),  ignoring  the missing values in the dataset.
 Median is `r medianOfTotalStepsPerDayfunction (  totalStepsEachDay )`


<!-- 
What is the average daily activity pattern?
-->
## Average daily activity pattern
<!-- 1. Make a time series plot (i.e. type = "l") of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all days (y-axis) -->
This is  a time series of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all days (y-axis).
```{R}
plotMeanStepsByInterval(t)
```


<!-- 2. Which 5-minute interval, on average across all the days in the dataset, contains the maximum number of steps -->
The greatest number of average steps in an interval (averaged across all days) is on interval , which is day 2, hour `r floor( ((5*806) -2*(60*24)) / 60)`, or interval number `r intervalWithMaxMeanStepsByIntervalBYMAXOFARRAY(t)` in the total dataset.
The greatest number of average steps is `r maxMeanStepsByInterval(t)`. 

An initial attempt to compute this maximum was implemented by the following code, which does not work. The lesson learned is that the base "R" language does not seem to provide a way to write a test expression (e.g. if statement conditional clause) to ask whether a variable contains NULL. The statement errors out just by attempting to refer to that variable. It also worth noting that the mean function returns a troublesome non-value if all of the elements it see are NA (rather than something useful such as NaN).
```{r}
intervalWithMaxMeanStepsByInterval
```



<!-- Imputing missing values -->
## Imputing missing values

This section explores the raw data. The raw data includes missing points where data was scheduled to be measured and failed to be captured.

<!-- 1.Calculate and report the total number of missing values in the dataset (i.e. the total number of rows with NAs) -->
1.  The total number of missing values in the dataset (i.e. the total number of rows with NAs) is`r totalMissingValues(t)`.

  
<!-- 2.Devise a [strategy](#interpolate) for filling in all of the missing values in the dataset. The strategy does not need to be sophisticated. For example, you could use the mean/median for that day, or the mean for that 5-minute interval, etc. -->
2. The strategy for filling in missing values (aka data smoothing) is to interpolate between the nearest non-missing values, as has already been described.

<!-- 3.Create a new dataset that is equal to the original dataset but with the missing data filled in.-->
3. The new dataset contains no NA values.
`r  tClean <- cleanData(t)`

<!-- 4.Make a histogram of the total number of steps taken each day and Calculate and report the mean and median total number of steps taken per day. --> 
4. The following is based on the revised activity data set.
#### Here is a histogram of the total number of steps each day.
```{r, echo=FALSE}
histClean( tClean)
```
It was discovered that all or nearly all blocks of time where NA is present (measurements missed) are preceeded and succeeded by zero steps. As a result of the interpolation strategy, which is based on interpolating the surrounding non-NA values, all these NA points are converted to zero steps.


<!-- Are there differences in activity patterns between weekdays and weekends -->
## Differences in activity patterns between weekdays and weekends


<!-- 1.Create a new factor variable -->
### New Factor variable
  To generate two plots, a factor variable is added to the dataset with two levels – “weekday” and “weekend” indicating whether a given date is a weekday or weekend day. The factor is defined as
```{r}weekdayWeekendFactor <-  factor( c(1,2), levels=c("Weekdays","Weekends"))
```

<!--2.Make a panel plot containing a time series plot (i.e. type = "l") of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all weekday days or weekend days (y-axis). See the README file in the GitHub repository to see an example of what this plot should look like using simulated data
-->
### Panel plot comparing weekday and weekend step patterns.
```{r}
plotWeekdayVsWeekendPanelFunction(tClean)
```

# Results
In a real research paper a Results section would interpret the results.

# Discussion
In a real research paper, additional ideas, implications, relationship to other work, and future work would be discussed here. 
I believe the problem of computing datasets with missing values that I encountered here will be a problem with many datasets in these courses and in the real world. As such, a solution must be found. The use of a mean across days, as suggested in the assignment instructions, would only obfuscate the underlying issues around blocks of missing data points.

# Conclusion
In a real research paper, this section would recap the paper.

# Supplementary Materials / gory details [#supp]


## Data-Cleaning Strategy

### Interpolation of missing data points.[#interpolate] 

The interpolation algorithm takes two parameters.
1. activity data.frame
2. MINOR_GAP =  `r MINOR_GAP()`, which the number of 5-minute intervals with NA that we consider "minor" for interpolation purposes. The interpolation will look ahead up to MINOR_GAP number of consecutive intervals with missing step values.

The interpolation function is: <!-- just list the code of cleanData here --/
```{r, echo=TRUE, eval=TRUE}
cleanData
```

**meanStepsPerDay** is
```{r, echo=TRUE, eval=TRUE}

meanStepsEachDayFunction(t)
```

## Exploratory Manual activity performed [#checksorted]
Scanned the activity data file to confirm that (1) steps column contains NA values, and (2) date and interval contain valid (non-NA) values.
```{r, echo=TRUE, eval=FALSE}
## Manual Check of input already sorted

# check that t is sorted by date, interval ...
s <- t[ order(t[,2], t[,3]), ]
 t[[1,1]] <- 55L
t.vec <- apply(t, 1, paste, collapse = "")
s.vec <- apply(s, 1, paste, collapse = "")
t.without.s.rows <- t[!t.vec %in% s.vec,]

# now you can also verify that this method of difference-finding works:
 t.vec[3] <-  505L
> head(t.without.s.rows)
[1] steps    date     interval
<0 rows> (or 0-length row.names)
> 
> t.without.s.rows <- t[!t.vec %in% s.vec,]
> head(t.without.s.rows)
  steps       date interval
3     0 2012-10-01       10
> head(t.vec)
[1] "   552012-10-01  ...
  
```


## Configuration Control

<!-- Configuration Control -->
### Computer architecture, Operating System
Windows edition
- Windows 8.1
system
- Processor: AMD A8-4500M APU with Radeon(tm) HD Graphics 1.90GHz
- Installed memory (RAM): 4.00 GB (3.47 GB usable)
- System type: 64-bit Operating System, x64-based processor
- Pen and Touch: No Pen or Touch Input is available for this Display
Computer name, domain, and workgroup settings
- Computer name: proprietary
- Computer description: (blank)
- Workgroup: WORKGROUP
Windows activation
- Windows is activated
- Product ID: 00179-60350-77560-AAOEM
Disk drives
- Hitachi HTS547564A9E384 SATA Disk
Filesystem
- System type: NTFS
- Settings: Allow indexing by contents


<!-- Configuration Control -->
### Software toolchain

Relavent tools (details follow).
- R, RStudio, 7-Zip, Notepad++, Git Bash, Git Gui, 

R
- version 3.2.0 for Windows 64-bit
- http://cran.r-project.org/bin/windows/base/

RSTudio
- http://www.rstudio.com/
Listing 1. R version and packages
```{r, echo=TRUE, eval=FALSE}
> sessionInfo()
R version 3.2.0 (2015-04-16)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows 8 x64 (build 9200)

locale:
[1] LC_COLLATE=English_United States.1252 
[2] LC_CTYPE=English_United States.1252   
[3] LC_MONETARY=English_United States.1252
[4] LC_NUMERIC=C                          
[5] LC_TIME=English_United States.1252    

attached base packages:
[1] stats     graphics  grDevices utils     datasets 
[6] methods   base     

loaded via a namespace (and not attached):
[1] tools_3.2.0
> 

```


7-Zip
- version 9.20
- author: Igor Pavlov
- http://www.7-zip.org/

Notepad++ 
- v6.6.9, Author: Notepad++ team
- https://notepad-plus-plus.org/

Git Bash
- version Git-1.9.5-preview20150319
- https://msysgit.github.io/

Git Gui
- author: Shawn Pearce, et al.
- git-gui version 0.49.DITGUI
- git version 1.9.5.msysgit.1
- Tcl/Tk version 8.5.13
- https://git-scm.com/downloads/guis

**Additional tools** that may be used in the Exploratory phase

Excel spreadsheet
- Microsoft Office 365

Cygwin
- https://www.cygwin.com/
- base-files version 4.2-3
- version file:
 DISTVERSION "4.1"
 BUILDVERSION 9
 DEFAULT_COMPAT_LEVEL 41
 SCCSVERSION "@(#)Bash version 4.1.17(9) release GNU"

perl
- perl5.14 




<!-- Configuration Control -->
### Software infrastructure

R Packages installed during this research

Internet browsers
- Google Chrome, version 43.0.2357.81.m
- Internet Exaplorer, version 11.0.9600.17801


<!-- Configuration Control -->
### External dependencies, version IDs

**data** for analysis. [#activity.csv]
  activity.csv [https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip)
  link found in:
    https://class.coursera.org/repdata-015/human_grading/view/courses/973516/assessments/3/submissions
**GitHub** for submission.
  https://github.com/rdpeng/RepData_PeerAssessment1
  

##### Missing data points
The sample measurements include some points with missing data. This could bias the results.
We take this into account in our analysis.
The total number of missing values in the sample is `print("MISSING NA")`
In order to compensate for missing data points we devised a simple procedure. It is based on the idea that the person's activity level changes more-or-less gradually, so the number of steps in one interval will be similar to that in adjacent intervals, on average.
This histogram appears to support this assumption.

##### Data-Cleaning Procedure

Each place-holder for missing data is replaced by interpolating the nearby non-missing points. This intermediate data is not stored.
