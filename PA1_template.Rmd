# Reproducible Research Assignment 1 PA_tempateA.Rmd
<!--
setwd("c:/edu/_DataScienceJohnsHopkins/_ReproducibleResearch/_ASGN1")
source("PA1_template.Rmd")
-->

This document is for [Assignment 1](https://class.coursera.org/repdata-015/human_grading/view/courses/973516/assessments/3/submissions).

##Loading and preprocessing the data


##A. Loading and processing the data

Current working directory is `r getwd()`.

###A.1.Load the data (i.e. read.csv())

```{r}
 t <-  read.table( "activity.csv",   header=TRUE, sep=",",  comment.char = "#",  quote = "\"", stringsAsFactors=FALSE)
```

Prepare environment.

```{r}
library(lattice)
```


###A.2. Process the data for analysis


##B. What is the mean of the daily totals of steps

Note. This chunk is used again in section D.4.

```{r}
dates <- unique( t$date )
datesWithNoMissingMeasurements <- 
    unique( t[ ! is.na( t[ t$interval==0,]$steps) & t$interval==0, ]$date )
totalStepsOnAGivenDay <- integer()
for (day in datesWithNoMissingMeasurements) {
     totalStepsOnAGivenDay[day] <- sum( t[  t$date==day, ][, "steps"] , na.rm=TRUE)
}

meanDailySteps <-  mean( totalStepsOnAGivenDay) 
```

There are `r length(dates)` days with measurement data after filtering out those with missing step measurements.

The average of the totals of steps per day is `r meanDailySteps` steps, ignoring missing data points. By "ignoring" missing values we mean we tell sum to remove NA values. This has the effect of changing NA values to zero, as determined through trial and error.


###B.1. Calculate the daily totals of steps

The total number of steps per day was `r sum( t[ , "steps"] , na.rm=TRUE)` steps, ignoring missing data points.

###B.2. Make a histogram of the total number of steps taken each day

This histogram tells on how many different days were the number of steps
in a certain range. There are 10 ranges because I set breaks=10, which is an arbitrary choice.

The histogram does not give a number of steps <i>for each day</i>. That interpretation of this requirement conflicts with the capabilities of the R hist() function which does not provide a way to input the x ranges explitly.

The ranges are calculated by the hist function but are not revealed. It kind-of looks like a range of step is about 2000. At the 5000 tic mark generated by hist() we see two and a half vertical bars. The first (left) bar tells us that on 10 difference days there were kind-of like between zero and 2000 steps. The next vertical bar kind-of tells us that on (looks like 2) 2 days, there were between 2000 and 4000 steps. And so on. (just one more: on 3 days we guess about 4000 5o 6000 steps).



```{r}
totalStepsOnEachDay <- unname(totalStepsOnAGivenDay)
hist( totalStepsOnEachDay, breaks=9)
```

# print("showed hist 1")
`


###B.3. Calculate and report the mean and median of the daily totals of steps

Note. This logic is reused in similar form in section D.4.(b).

```{r}
averageDailySteps <- mean( t[, "steps"] , na.rm=TRUE)
medianDailySteps <- median( t[, "steps"] , na.rm=TRUE)
```

The average number of steps per day during all days of the experiment where measurements were present is `r round(averageDailySteps, 5)` steps.

The median number of steps per day during all days of the experiment where measurements were present is `r round(medianDailySteps,1)` steps.


##C. What is the average daily activity pattern?

###C.1. Time series plot (i.e. type = "l") of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all days (y-axis)

A comparable plot will be generated in section D. So the plotting code is defined as a function.

```{r}
plotStepsByIntervals <- function( ta) {
  avgStepsPerInterval <- aggregate(steps ~ interval, ta, mean)
  plot(avgStepsPerInterval$interval, avgStepsPerInterval$steps, 
       ylab = "Average number of steps taken", 
       xlab = "Interval", type = "l")
  avgStepsPerInterval
}

avgStepsPerInterval <- plotStepsByIntervals(t)

```

###C.2. Which 5-minute interval, on average across all the days in the dataset, contains the maximum number of steps?

```{r}
maxAverageSteps <- avgStepsPerInterval[avgStepsPerInterval$steps == max(avgStepsPerInterval$steps),"interval"]
intervalWithMaxAverageSteps <- avgStepsPerInterval[avgStepsPerInterval$steps == max(avgStepsPerInterval$steps),]$interval
```

The 5-minute interval, on average across all the days in the dataset, which contains the maximum number of steps is interval `r intervalWithMaxAverageSteps`-`r intervalWithMaxAverageSteps+5`.



##D. Imputing missing values

For experiments that I have been involved with it was unthinkable to fabricate values to "fill in" for missing measurements. The approach I have taken is this: derive two complete copies of the measurement date according to a minimum assumption and a maximum assuption, respectively. So, for example in the minimal set, all null values are changed to the lowest applicable values, such as zero. In the maximal set the nulls are changed to the maximum conceivable value (depending on the nature of the experiment some judgment applies).
Then run the analysis on both. When you generate summary statistics and plots you can see clearly  the impact as an uncertainty range that is a consequence of the missed measurements. ... and then decide whether it is a problem.
After the patterns emerge there might be evidence for justifying the estimate of missing measurements by interpolation or some kind from points that are now demonstrated to have a sufficiently strong relationship.

But this assignment has imposed the approach of fabricating estimates that look good and are easy to generate.

###D.1. Calculate and report the total number of missing values in the dataset (i.e. the total number of rows with NAs)

```{r}
  missingValuesCount <- length( t$interval) - length( t[ is.na(t$steps) , ]$interval)
```

The number of intervals without a measurement is `r missingValuesCount`.

###D.2. Devise a strategy for filling in all of the missing values in the dataset.


####The simple principle for selecting related measurements is this:

Look at the adjacent days of the same part of the week, and average their interval measurements in the hour surrounding the problem interval.

To clarify further:

The strategy is to find the average value during the corresponding hour across the adjacent days of the same part of the week. The "part of the week" means weekdays or weekends. My justification for considering the parts of week separately is based on the cultural norm in which physical activities are often different on weekdays and weekends. So, estimates for missing measurements should not draw from the other part of the week. My justification for considering the corresponding intervals within a one hour range is that activity might be similar around the approximate same time on adjacent days. My justification for using only the two closest adjacent days is that the estimatation is mostly based on the possible similarity of activity during the same hour. The calculation also assumes that a further averaging across more than the adjacent days will yield no better estimation than that of the adjacent days where activity might possibly be at least as similar to that of the day with missing measurements.

Here are some examples. Given a missing measurement on Saturday at interval `r hour <-13
width <- 6
hour*12-1`, which is `r hour-12`pm, we consider intervals `r hour*12-1` minus `r width` thru plus  `r width`  giving intervals `r 13*12-1 -width` thru `r 13*12-1 +width` on that week part (Saturday thru Sunday). Its adjacent day is that Sunday. (If we were looking at a Sunday interval, an adjacent day might be the previous or next weekend date.)  Call this set of values the "related" points for the missing measurement under consideration. If the interval under consideration belongs to Friday, a weekday, its adjacent date is the following Monday.

###D.3. Create a new dataset that is equal to the original dataset but with the missing data filled in.

A "new" dataset is accomplished by generating the list of days having measurement data and selecting by those dates for computations, rather than creating a separate modified copy of the whole dataset.

Here is a summary of the steps that implement the strategy for fabricating values to replace missing measurements:

1. Generate a list of dates for the weekend and weekday parts of the week
   Now do the same for each part of the week.
   
2. Generate a list of the days that are missing measurements.

3.   For each of these "miss days" generate the two adjacent days that are in the same part of the week and are not themselves "miss days".
   
4. For each "miss day" . . .

5.   initialize a window of one hour on the two adjacent days
     
6.   for each interval . . .

7.        update the average steps: 
            the average of the two current one hour windows
8.        assign that average to the current interval of the current miss day.


####NOTE 6.

This algorithm assumes that the only intervals with missing measurement values
are those on days where all of the measurements are missing.
This assumption is valid for the given data of this assignment. 
The assumption allows the algorithm to avoid checking each candidate interval-with-measurement values
  that might otherwise have contributed to an estimate to fill in missing data.


###Here is the implementation. (D.3.)

####1. Generate a list of dates for the weekend and weekday parts of the week

```{r}
datesAsDate <- as.Date(dates)
weekdayDatesAsString <- c()
weekendDatesAsString <- c()
for (day in dates) {
    dateAsDate <- as.Date( day)
    dayofweekLetter <- substring( weekdays(dateAsDate), 1,1)
    if (dayofweekLetter == "S") { # only Sat and Sun start with S
      weekendDatesAsString <- c(weekendDatesAsString, day)
    } else {
      weekdayDatesAsString <- c(weekdayDatesAsString, day)
    }
}
```

So, incidentally, the experiment was performed on `r length(weekendDatesAsString)` weekend dates and  `r length(weekdayDatesAsString)` weekend dates.


####2. Generate a list of the days that are missing measurements.

```{r}
missdaysWeekend <- c()
for (day in weekendDatesAsString) {
  if ( is.na( t[ t$date==day & t$interval==0 , ]$steps)) {
    missdaysWeekend <- c(missdaysWeekend, day)
  } else {
   }
}
missdaysWeekday <- c()
for (day in weekdayDatesAsString) {
  if ( is.na( t[ t$date==day & t$interval==0 , ]$steps)) {
    missdaysWeekday <- c(missdaysWeekday, day)
  }
}
```

There were `r length(missdaysWeekend)` weekend and `r length(missdaysWeekday)` days  missing measurement data, `r length(missdaysWeekend)+ length(missdaysWeekday)` all together.

####3. For each of these "miss days" generate the two nearest adjacent days that are in the same part of the week and are not themselves "miss days".
   
   
   # debug:
   missdayWeekpart <- missdaysWeekend
   weekpartDayDatesAsString <- weekendDatesAsString
```{r}
missdaysAdjacentGenerate <- function( missdayWeekpart, weekpartDayDatesAsString) {
        # missdaysWeekday, missdaysWeekend.  return: missdaysAdjacent
  
  missdaysAdjacent <- list()
  ## names(missdaysAdjacent) <- c("date","adjacentDays")
  
  for (missday in missdayWeekpart ) {
    # debug: missday <- "2012-11-04"
    dNext <- c()
    dPrev <- c()
     # print( sprintf("missday:%s", missday))
    for (day in weekpartDayDatesAsString) {
      #print( sprintf("day:%s", day))
      # debug: day <- "2012-10-06"
      if (day != missday) {
        if (as.Date(day) < as.Date(missday)) {
      #print( sprintf(" dPrev GOT day:%s", day))
          dPrev = day
        }
        if (length(dNext) == 0) {
          if (as.Date(day) > as.Date(missday)) {
      #print( sprintf(" dNext GOT day:%s", day))
            dNext = day
          }
        }
      }
    }
    
    if (length(dNext)==0 | length(dPrev)==0) { # then assign first available
       for (day in weekpartDayDatesAsString) {
          if (day != missday   ) { # don't consider already used
            if (length(dNext)==0   && day != dPrev) {
              dNext <- day
            } else if (length(dPrev)==0  && day != dNext) {
              dPrev <- day
            }
          }
       }
    }
    
    
     missdaysAdjacent[[missday]] <- c(dPrev, dNext)
    ## missdaysAdjacent[missday] <- paste(dPrev, dNext)
  }
  missdaysAdjacent
}
```


```{r}
####4. For each "miss day" of both parts of the week . . .


missdaysAdjacentDaysWeekend <-
    missdaysAdjacentGenerate( missdaysWeekend, weekendDatesAsString)

missdaysAdjacentDaysWeekday <-
    missdaysAdjacentGenerate( missdaysWeekday, weekdayDatesAsString)
```

missdaysAdjacentDaysWeekend and missdaysAdjacentDaysWeekday are now list structures keyed by date and having a string value which is the previousAdjacentDate, space, nextAdjacentDate.
This string format was decided because I couldn't find a way to accumulate
two-valued keyed tuples.


Modify the dataset, t, with estimated number of steps for missing interval data


# convert pure minutes, used for time arithmetic, to the data.frame's interval representation
# e.g. data.frame has "100" for 1 hour. 105 for 65 minutes.
# in order to generate the data.frame representation of a one hour set of intervals
# around the target interval, first convert to pure minutes, do the arithmetic, then backto data.frame's representation
```{r}
pureMinuteToHourMinute<- function( minuteInterval) {
    hour <- as.integer( minuteInterval / 60) 
    minute <- as.integer( minuteInterval - hour * 60 ) 
    hourminute <-  as.integer( 100*hour + minute )
  hourminute 
}


# convert the time representation of the data.frame to pure minutes
hourMinuteToPureMinute <- function( hourminute) {
    hourRepresentation <- as.integer( hourminute / 100)
    minute <-  as.integer( hourminute - hourRepresentation*100 )
    intervalMinute <-  hourRepresentation * 60 + minute
  intervalMinute
}
```
    # debug
    # t no change
    # missdaysWeekend <- missdayWeekpart
    # missdaysAdjacentDays <- missdaysAdjacentDaysWeekend
    
```{r}
applyMeanOfAdjacentDaysSameHour <-                     # no return value
    function(  missdayWeekpart, missdaysAdjacentDays) {
   # function( t, missdayWeekpart, missdaysAdjacentDays) {
      # t - the original dataset
      # missdayWeekpart - list of either weekend or weekday dates
      # missdaysAdjacentDays - list: key: date, value: vector of prev and next dates.
      
     # print("STARTING #####################")
    # print("STARTING #####################")
#tt2 <-  t[ t$date=="2012-11-04"  & t$interval==60, ] 
 #         print( sprintf("tt2:%s", tt2 ))
  #        print( sprintf("tt2$steps:%s", tt2$steps ))
   #       print( sprintf("t[ t$date==\"2012-11-04\"  & t$interval==60, ]$steps:%s", t[ t$date=="2012-11-04"  & t$interval==60, ]$steps ))
          
      
    for ( missday in missdayWeekpart) {
      
      # debug: missdaysAdjacentDays[missday]

        vectorOfNextPrev  <- unname( unlist( missdaysAdjacentDays[missday]))
        missdaysAdjacentDatePrev <- vectorOfNextPrev[1]
        missdaysAdjacentDateNext <- vectorOfNextPrev[2]

 #print( sprintf("missdaysAdjacentDatePrev:%s", missdaysAdjacentDatePrev))
 #print( sprintf("missdaysAdjacentDateNext:%s", missdaysAdjacentDateNext))

# 5. initialize a window of one hour
        hourWindow <- -6:5 # twelve 5-minute intervals around a given interval-missing-measurement na.rm

        
# 6. for each interval . . .
      # hourMinuteIntervalRepresentations <- seq( 0, hourMinuteToPureMinute(2355),5)
      
        hourMinuteIntervalRepresentations <- lapply( seq( 0, hourMinuteToPureMinute(2355),5), pureMinuteToHourMinute )
       
        for (interval in  hourMinuteIntervalRepresentations) {
          
          s <- 0 # sum for calculating mean of related intervals
          numberOfRelatedIntervalsAveragedIn <- 0 # n for mean of related intervals
          
          
          for ( hourWindowIntervalMinuteOffset in hourWindow) {
            relatedInterval <- pureMinuteToHourMinute (
              hourMinuteToPureMinute ( interval)+ hourMinuteToPureMinute ( 5* hourWindowIntervalMinuteOffset)
            )
            
            if (-1 < relatedInterval
                && relatedInterval < (2355)) { # keep hour in same day
              
  #             print( sprintf("relatedInterval: %s,  missdaysAdjacentDatePrev:%s", relatedInterval, missdaysAdjacentDatePrev))
              
              ############# TODO: put this section in a loop over the Prev and Next dates
              adjacentDateRelatedIntervalStepsValue <-
                      t[ t$date==missdaysAdjacentDatePrev & t$interval==relatedInterval, ]$steps

                 #            print( sprintf("adjacentDateRelatedIntervalStepsValue: %s", adjacentDateRelatedIntervalStepsValue))
              if ( length(adjacentDateRelatedIntervalStepsValue) > 0) {
                  # & !is.na( adjacentDateRelatedIntervalStepsValue) TODO
                  # & adjacentDateRelatedIntervalStepsValue != 0) {

#note 6
                  s <- s + adjacentDateRelatedIntervalStepsValue
                  numberOfRelatedIntervalsAveragedIn <- 
                      numberOfRelatedIntervalsAveragedIn + 1
# print( sprintf("s:%s,numberOfRelatedIntervalsAveragedIn:%s ", s, numberOfRelatedIntervalsAveragedIn))
              }
            }
          }
          
#7.update the average steps:
          # mean of up to 12 interval's steps from Adjacent missdays in same weekpart
          if (numberOfRelatedIntervalsAveragedIn != 0) {
       #     m <- 1200*s / numberOfRelatedIntervalsAveragedIn
            m <- s / numberOfRelatedIntervalsAveragedIn  #REINSTATED
           # print( sprintf("m 1 :%s ", m))
          } else {
            # print( sprintf("m 2 :%s ZERO", m))
            m <- 0
          }
#8. assign that average to the current interval of the current miss day.
        #  print( sprintf("missday:%s, interval:%s", missday, interval))
      
         tt <-  t[ t$date==missday  & t$interval==interval, ] 
         # print( sprintf("tt1:%s", tt ))
             tt$steps <- m
        #WAS  measurementVector <- t[  t[ t$date == missday, ]$interval==interval, ]
          
          
          
       #   print( sprintf("measurementVector:%s", measurementVector ))
       #    print( sprintf("measurementVector$date:%s", measurementVector$date ))
        #  print( sprintf("measurementVector$interval:%s", measurementVector$interval ))
        #  print( sprintf("measurementVector$steps:%s", measurementVector$steps ))
 
        #  print( sprintf("t[  t[ t$date == missday, ]$interval==interval, ]$steps:%s",  t[  t[ t$date == missday, ]$interval==interval, ]$steps))
         
          
         # t[ t$date == missday & t$interval==interval, ]$steps <-  m
        }
    }
  invisible()
}
```

Apply the fabricated values to the intervals missing measurements.

```{r}
applyMeanOfAdjacentDaysSameHour(  missdaysWeekend, missdaysAdjacentDaysWeekend)
applyMeanOfAdjacentDaysSameHour(  missdaysWeekday, missdaysAdjacentDaysWeekday)
```

####Here is a summary of effort to fabricate data in place of missing measurements:

1. countFabricatedValues: r countFabricatedValues
4. count of missing measurements for which no value could be fabricated: r countFabricatedValuesUnable, substituted zero.
2. countFabricatedValuesOfWeekday: r countFabricatedValuesOfWeekday
3. countFabricatedValuesOfWeekend: r countFabricatedValuesOfWeekend

Total of weekday and weekend fabricated values: r countFabricatedValuesOfWeekday + countFabricatedValuesOfWeekend, should equal countFabricatedValues: r countFabricatedValues.




###D.4.(a) Make a histogram of the total number of steps taken each day and Calculate and report the mean and median total number of steps taken per day.

This logic is the same as in B.2. but now there are no days with missing measurements in t. <i> It is repeated here instead of using a function becuase of the convenience of getting the totalStepsOnAGivenDay in the current scope.</i>

```{r}
dates <- unique( t[ ! is.na( t[ t$interval==0,]$steps) & t$interval==0, ]$date)
totalStepsOnAGivenDay <- integer()
for (day in dates) {
     totalStepsOnAGivenDay[day] <- sum( t[  t$date==day, ][, "steps"] , na.rm=TRUE)
}

meanDailySteps <-  mean( totalStepsOnAGivenDay) 
```

There are now `r length(dates)` days with measured and estimated step data.

```{r}
totalStepsOnEachDay <- unname(totalStepsOnAGivenDay)
hist( totalStepsOnEachDay, breaks=9)
```

# print("showed hist 2")
`

###D.4.(b) Calculate and report the mean and median total number of steps taken per day. 
Note. this logic is similar to that in B.3 but expects no missing measurements.

```{r}
averageDailyStepsWithEstimates <- mean( t[, "steps"] , na.rm=TRUE)
medianDailyStepsWithEstimates <- median( t[, "steps"] , na.rm=TRUE)
```

The average number of steps per day during all days of the experiment is `r round(averageDailySteps, 5)` steps.

The median number of steps per day during all days of the experiment is `r medianDailySteps` steps.



###D.4.(c) Do these values differ from the estimates from the first part of the assignment?

The average number of steps including estimated counts is `r round(averageDailyStepsWithEstimates, 5)` steps.
The average daily steps with and without estimates differ by `r averageDailyStepsWithEstimates - averageDailySteps`


The median steps including estimated counts is `r round(medianDailyStepsWithEstimates, 1)` steps.
The median daily steps with and without estimates differ by `r medianDailyStepsWithEstimates - medianDailyStepsWithEstimates`



###D.4.(d) What is the impact of imputing missing data on the estimates of the total daily number of steps?

The use of averages to estimate values for missing measurements had no significant effect.
This is considered good. If the fabricated data had pushed the overall mean significantly, it would call into question any inferences that might otherwise be made.



##E. Are there differences in activity patterns between weekdays and weekends?


###E.1. Create a new factor variable in the dataset with two levels – “weekday” and “weekend” indicating whether a given date is a weekday or weekend day.

```{r}
t$weekpart <- as.factor( ifelse( t$date %in% weekdayDatesAsString, yes="weekend", no="weekday"))
```


###E.2. Make a panel plot containing a time series plot (i.e. type = "l") of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all weekday days or weekend days (y-axis). See the README file in the GitHub repository to see an example of what this plot should look like using simulated data.

```{r}
avgStepsPerIntervalsOfWeekparts <- aggregate(steps ~ weekpart + interval, t, mean)

xyplot(steps ~ interval | weekpart, data = avgStepsPerIntervalsOfWeekparts,layout=c(2, 1), type = "l")
```


